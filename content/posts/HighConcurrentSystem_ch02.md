---
title: "HighConcurrentSystem_ch02"
date: 2023-03-29T23:01:47+08:00
draft: false
tags:
  - 高并发系统 

---

# 用户中心-缓存一致：读多写少时，如何解决数据更新缓存不同步？

> 用户中心这种读多写少的场景特别适合做读取缓存，通过缓存大大降低系统数据层的查询压力，但使用缓存后往往会碰到更新不同步的问题。

## 缓存性价比

将 2000 万的账号信息放到缓存，肯定能提供性能很好的服务。它的性价比并不高：这个表查询的场景主要用于账号登录，用户即使频繁登录，也不会造成太大的流量冲击。因此，缓存在大部分时间是闲置状态，我们没必要将并发不高的数据放到缓存当中，浪费我们的预算。

我们需要评估缓存是否有效，一般来说，只有热点数据放到缓存才更有价值。

## 临时热缓存

我们把目标放到会被高频查询的信息上，也就是用户信息。在很多场景下会被频繁查询展示，比如我们在论坛上看到的发帖人头像、昵称、性别等，这些都是需要频繁展示的数据，不过这些数据的总量很大，全部放入缓存很浪费空间。

对于这种数据，建议使用临时缓存方式，就是在用户信息第一次被使用的时候，同时将数据放到缓存当中，短期内如果再次有类似的查询就可以快速从缓存中获取。这个方式能有效降低数据库的查询压力。

这种临时缓存适合表中数据量大，但热数据少的情况，可以降低热点数据的压力。而之所以给缓存设置数据 TTL，是为了节省我们的内存空间。当数据在一段时间内不被使用后就会被淘汰，这样我们就不用购买太大的内存了。这种方式相对来说有极高的性价比，并且维护简单，很常用。

## 缓存更新不及时问题

临时缓存是有 TTL 的，如果 60 秒内修改了用户的昵称，缓存是不会马上更新的。最糟糕的情况是在 60 秒后才会刷新这个用户的昵称缓存，显然这会给系统带来一些不必要的麻烦。

1. 单条实体数据缓存刷新。 在更新某条mysql数据是删除这条对应的缓存数据
2. 关系型和统计型数据缓存刷新。 人工维护缓存方式；订阅数据库找到ID数据变化（使用Maxwell或Canal对Mysql的更新实时监控）；版本号缓存设计，一旦有任何更新，整个表内所有数据缓存一起过期；异步脚本遍历数据库库刷新所有相关缓存。

## 长期热数据缓存

临时缓存虽能解决大部分问题，但当TTL到期时，若大量缓存请求没有命中，透传的流量可能会打穿我们的数据库，即缓存穿透问题，服务可能宕机。

长期缓存和临时缓存的混用。当我们要查询某个用户信息时，如果缓存中没有数据，长期缓存会直接返回没有找到，临时缓存则直接走更新流程。此外，我们的用户信息如果属于热点 key，并且在缓存中找不到的话，就直接返回数据不存在。

singleflight

## 总结

不是所有的数据放在缓存就能有很好的收益，我们要从数据量、使用频率、缓存命中率三个角度去分析。读多写少的数据做缓存虽然能降低数据层的压力，但要根据一致性需求对其缓存的数据做更新。其中，单条实体数据最容易实现缓存更新，但是有条件查询的统计结果并不容易做到实时更新
